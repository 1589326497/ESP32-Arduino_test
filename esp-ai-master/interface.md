
# 客户端接口文档

在编写客户端之前先通读一遍本文档，因为本文档接口顺序并不是按照业务流程顺序编写。

## 规约
- 客户端与服务端之间永远只通过一个 `WebSocket` 连接进行通信。
- 交互数据格式为 `字符串` 或者 `JSON 字符串`，两种格式
- 客户端要以性能和稳定为最主要的方面 

## 服务连接
连接路径上必须增加客户端版本，如下：
``` c++
String Version = "1.0.0";
webSocket.begin("192.168.3.3", 8080, "/?v=" + Version);
```

## S1. 服务端下发-是否可采集音频
一边采集音频进行离线唤醒，一边接受服务音频数据送至扬声器会卡顿，所以客户端代码在接收到本时数据时，需要暂停或者继续音频采集与上传。避免客户端播放音频卡顿。

### 数据类型

- 字符串：`"start_voice"` 表示建议客户端开启音频采集与离线唤醒推理
- 字符串：`"pause_voice"` 表示建议客户端暂停音频采集与离线唤醒推理

## S2. 服务端下发-会话是否结束
用户唤醒 "小明同学" 直至与小明同学对话结束为一轮会话，服务端会下发一个字符串 `"end_session"` 表示当前会话结束。

### 数据类型

- 字符串：`"session_end"` 

## S3. 服务端下发-用户指令
当接口 S1、S2 都不存在时，就需要对数据进行 `JSON` 格式解析，获取用户指令。

比如用户呼喊 “关灯”, 并且开发者在服务端配置了指令“关灯”，那么服务端会下发一个 `JSON` 字符串。
其中 `type: "instruct"`是固定的。只有这个类型的指令才是定义的用户的指令。
### 数据类型：
``` c++
{
    "type":"instruct", 
    "command_id":"服务端配置的命令ID，根据这个id进行引脚上电控制等",
    "data":"服务端绑定的额外参数"
}
```


## S4. 服务端下发-音频播放任务ID
当接口 S1、S2 都不存在时，就需要对数据进行 `JSON` 格式解析，获取用户指令。

当服务端向客户端发送二进制音频之前会先发送这个命令到客户端。
客户端需要记录本次音频的任务ID。
### 数据类型：
``` c++
{
    "type":"play_audio", 
    "tts_task_id":"TTS任务ID, 需要全局记录。"
}
```

## C1. 客户端发送-客户端已连接到服务

当客户端接入`ws`服务后，需要立马给服务端发送本消息。

### 数据类型：
向服务端发送一个 JSON 字符串即可：
``` c++
webSocket.sendTXT('{"type":"play_audio_ws_conntceed"}');
```

## C2. 客户端发送-音频播放完毕
向服务端发送音频播放完毕的命令。通常在 800ms 这个时间后接收不到服务端音频流即可视为服务端音频发送完毕。也意味着客户端播放完毕。

### 数据类型： 
向服务端发送一个 JSON 字符串即可：
``` c++
webSocket.sendTXT('{"type":"client_out_audio_over","tts_task_id":"上面保存的TTS任务ID"}');
```

## C3. 客户端发送-开始语音识别命令
当客户端被唤醒时，需要立马调用本接口

### 数据类型：
向服务端发送一个 JSON 字符串即可：
``` c++
webSocket.sendTXT('{"type":"start"}');
```

## C4. 客户端发送-实时音频数据
当客户端被唤醒后，客户端就需要实时将音频数据推给服务器，由服务器转交给 `IAT` 服务以及后续的一系列操作。

### 数据类型：
``` c++
// 一般写法：直接读取 i2s 接口数据，然后传给服务端。
i2s_read(I2S_NUM_1, (void *)sampleBuffer, i2s_bytes_to_read, &bytes_read, portMAX_DELAY);

webSocket.sendBIN((uint8_t *)sampleBuffer, bytes_read);
```
